---
layout: post
title:  "Ruby on Rails: Setup a belongs_to association with multiple columns/attributes referencing the same model"
date:   2018-04-04 17:06:33 +0800
categories: ruby rails
tags: [ ruby, rails ]
---
I've been building an inventory system this past week and wrote a code that made
me remember my past roadblocks during the time I started using Ruby on Rails
for my projects. It was about setting up a belongs_to association with multiple
columns/attributes referencing the same model.

On this example there are two models, User and TransferRequest. The User and
TransferRequest has a one to many relationship. TransferRequest has attributes
sender and receiver which are instances of User. I had problems setting up
associations like this when I started because of my lack of understanding and
reliance on Rail's 'magical' generators to build the database.

User was generated by executing the command:

{% highlight shell %}
# Generates a User model.
rails g model User name
{% endhighlight %}

The User model will look like this:
{% highlight ruby %}
# app/models/transfer_request.rb
class User < ApplicationRecord
end
{% endhighlight %}

Now generate the TransferModel by executing the command:
{% highlight shell %}
# Generates a TransferRequest model
rails g model TransferRequest sender:references receiver:references
{% endhighlight %}

The code for TransferRequest should look like this:
{% highlight ruby %}
# app/models/transfer_request.rb
class TransferRequest < ApplicationRecord
  belongs_to :sender
  belongs_to :receiver
end
{% endhighlight %}

A migration file to create the table for TransferRequest will also be generated.

{% highlight ruby %}
# db/migrations/20180404063005_create_transfer_requests.rb
class CreateTransferRequests < ActiveRecord::Migration[5.1]
  def change
    create_table :transfer_requests do |t|
      t.references :sender, foreign_key: true
      t.references :receiver, foreign_key: true

      t.timestamps
    end
  end
end
{% endhighlight %}

When I was new to Ruby on Rails, I would think that this is enough to setup the
model TransferAsset and the association with its attributes. Let's run a
migration and see what happens by executing the command below.

{% highlight shell %}
rails db:migrate # Same as rake db:migrate
{% endhighlight %}

The command above would fail and show an error. At the CreateTransferRequest
migration file, the table 'transfer_request' references its attribute 'sender'
as a foreign key and because of this Rails assumed that a table called 'sender'
exists which does not. The same is true for the attribute 'receiver'. To fix
this, the value of the foreign_key should be false or we can just ommit the part
where the foreign_key is passed since it is false by default like the code below.

{% highlight ruby %}
# db/migrations/20180404063005_create_transfer_requests.rb
class CreateTransferRequests < ActiveRecord::Migration[5.1]
  def change
    create_table :transfer_requests do |t|
      t.references :sender
      t.references :receiver

      t.timestamps
    end
  end
end
{% endhighlight %}

Now lets run the migration which creates a table for User and TransferRequest.
{% highlight shell %}
rails db:migrate # Same as rake db:migrate
{% endhighlight %}

Running the migration will modify the db/schema.rb.
This piece of code will be added to it.

{% highlight ruby %}
# db/schema.rb
create_table "transfer_requests", force: :cascade do |t|
  t.bigint "sender_id"
  t.bigint "receiver_id"
  t.datetime "created_at", null: false
  t.datetime "updated_at", null: false
  t.index ["receiver_id"], name: "index_transfer_requests_on_receiver_id"
  t.index ["sender_id"], name: "index_transfer_requests_on_sender_id"
end
{% endhighlight %}

This instructs Rails Active Record to create the table 'tansfer_request' with
columns 'sender_id' and 'receiver_id' which is represented by TransferRequest as
a model.

TransferRequest still doesn't know that its attributes 'sender' and 'receiver'
are instances of User so we pass class_name: 'User' as an argument to the method
belongs_to at the TransferRequest model.

{% highlight ruby %}
# app/models/transfer_request.rb
class TransferRequest < ApplicationRecord
  belongs_to :sender, class_name: 'User'
  belongs_to :receiver, class_name: 'User'
end
{% endhighlight %}


User doesn't know that it has many senders and receivers. Both from the table
'transfer_request'. Modify the User model to associate it with TransferRequest.
The User should look like this:

{% highlight ruby %}
# app/models/user.rb
class User < ApplicationRecord
  has_many :sender_transfer_request, class_name: 'TransferRequest',
    foreign_key: 'sender_id'
  has_many :receiver_transfer_request, class_name: 'TransferRequest',
    foreign_key: 'receiver_id'

  validates :email, presence: true, uniqueness: true
  validates :name, presence: true
end
{% endhighlight %}

Here the method 'has_many' was called passing a symbol ending with
'_transfer_request' as the first argument following the naming convention for
Active Record association. The second argument tells Rails that it is an
instance of TranferRequest. The third argument specifies which the column of the
of the table "transfer_request' is the foreign key.

And thats it!
