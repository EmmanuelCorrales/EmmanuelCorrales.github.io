---
layout: post
title:  "Ruby on Rails: Setting up a table with multiple columns with the same model"
date:   2018-04-04 17:06:33 +0800
categories: ruby rails
tags: [ ruby, rails ]
---
Rails's Active Record has made setting up database tables easier by representing
tables as models including their association with other tables. However there
are cases when just knowing

I've been working on building an inventory system for the past week and wrote a
code that made me remember my past predicament when I was just starting to use
Ruby on Rails for my projects. It was about setting up a table with multiple
columns represented by the same model.

I have a model called TransferRequest and it has the attributes sender and
receiver which are references to the model called User. User was generated by
executing the command below.

{% highlight shell %}
# Generates a User model.
rails g model User name
{% endhighlight %}

The command above will generate this code:
{% highlight ruby %}
# app/models/transfer_request.rb
class User < ApplicationRecord
end
{% endhighlight %}

TransferRequest was generated by executing the command below.
{% highlight shell %}
# Generates a TransferRequest model
rails g model TransferRequest sender:references receiver:references
{% endhighlight %}

The code for TransferRequest should look like this.
{% highlight ruby %}
# app/models/transfer_request.rb
class TransferRequest < ApplicationRecord
  belongs_to :sender
  belongs_to :receiver
end
{% endhighlight %}

It will also generate a migration called TransferRequest.

{% highlight ruby %}
# db/migrations/20180404063005_create_transfer_requests.rb
class CreateTransferRequests < ActiveRecord::Migration[5.1]
  def change
    create_table :transfer_requests do |t|
      t.references :sender, foreign_key: true
      t.references :receiver, foreign_key: true

      t.timestamps
    end
  end
end
{% endhighlight %}

When I was new to Ruby on Rails, I would think that this is sufficient enough to
to setup the model TransferAsset and the association with its attributes. Let's
run a migration and see what happens by executing the command below.

{% highlight shell %}
rails db:migrate # Same as rake db:migrate
{% endhighlight %}

The command above would fail and show an error. On the CreateTransferRequest
migration file the table 'transfer_request' references its attribute 'sender' as
a foreign key and because of this Rails assumed that a table called 'sender'
exists which does not. The same is true for the attribute 'receiver'. To fix
this, the value of foreign_key should be false or we can just ommit the part
where the foreign_key is passed since it is false by default like the code below.

{% highlight ruby %}
class CreateTransferRequests < ActiveRecord::Migration[5.1]
  def change
    create_table :transfer_requests do |t|
      t.references :sender
      t.references :receiver

      t.timestamps
    end
  end
end
{% endhighlight %}

Now lets run the migration which creates a table for TransferRequest.
{% highlight shell %}
rails db:migrate # Same as rake db:migrate
{% endhighlight %}

Running the migration will modify the db/schema.rb.
This piece of code will be added to it.
{% highlight ruby %}
# db/schema.rb
create_table "transfer_requests", force: :cascade do |t|
  t.bigint "sender_id"
  t.bigint "receiver_id"
  t.datetime "created_at", null: false
  t.datetime "updated_at", null: false
  t.index ["receiver_id"], name: "index_transfer_requests_on_receiver_id"
  t.index ["sender_id"], name: "index_transfer_requests_on_sender_id"
end
{% endhighlight %}


The model TransferRequest represents a table named 'transfer_request' with
columns 'sender_id' and 'receiver_id'. Rails doesn't yet know that 'sender_id'
and 'receiver_id' are foreign keys for the table named 'user' which is
represented by the model User. In order for Rails to understand that both
'sender' and 'receiver' are represented by User, we pass class_name: 'User' as
arguments to the method belongs_to in the TransferRequest model like the code below.

{% highlight ruby %}
# app/models/transfer_request.rb
class TransferRequest < ApplicationRecord
  belongs_to :sender, class_name: 'User'
  belongs_to :receiver, class_name: 'User'
end
{% endhighlight %}


Set the relationship that TransferRequest belongs to a 'sender' and a 'receiver'
so that Rails will look for columns 'sender_id' and 'receiver_id' instead
of tables that are named 'sender' and 'receiver'. Pass 'User' as argument
for class_name so that Rails will know that 'sender' and 'receiver' are
instances of 'User'.


Set the relationship that the model User has many senders and receivers. Pass
 'TransferRequest' as the argument value for class_name so that Rails will know
 that 'sender' and 'receiver' are instances of 'TransferRequest'. Pass sender_id
 and receiver_id as argument for foreign_key so that Rails can identify
 which column of the TransferRequest table should store the corresponding
 foreign keys.

{% highlight ruby %}
class User < ApplicationRecord
  has_many :sender_transfer_request, class_name: 'TransferRequest',
    foreign_key: 'sender_id'
  has_many :receiver_transfer_request, class_name: 'TransferRequest',
    foreign_key: 'receiver_id'

  validates :email, presence: true, uniqueness: true
  validates :name, presence: true
end
{% endhighlight %}
